import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    id 'base'
    id 'java-library'
    // Build Scans
    id 'com.gradle.build-scan' version '2.0.2'

    // For JNI
    id 'cpp'
    id 'edu.wpi.first.GradleVsCode' version '0.8.0'
    id "edu.wpi.first.GradleJni" version "0.4.1"
    id "edu.wpi.first.GradleRIO" version "2019.3.2"

    // Task Tree
    id "com.dorongold.task-tree" version "1.3.1"
}

compileJava {
    options.compilerArgs << '-Xlint:deprecation'
}

// Use Gradle 5.0 as GradleRIO only supports 5.0
wrapper {
    gradleVersion = 5.0
}

buildScan {
    termsOfServiceUrl = 'https://gradle.com/terms-of-service'
    termsOfServiceAgree = 'yes'
}

dependencies {
    // JMathPlot is needed for the graphing
    implementation 'com.github.yannrichet:JMathPlot:1.0.1'
    // Gson is needed for the Trajectory Visualizer's saving
    implementation 'com.google.code.gson:gson:2.8.5'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
    testImplementation 'org.hamcrest:hamcrest:2.1'
}

// In this section you declare where to find the dependencies of your project
repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

project.version = '3.0.0-alpha.0'

// Setup for Gradle-JNI
// Thanks to @ThadHouse
model {
    components {
        JniLibrary(JniNativeLibrarySpec) {
            // Target both desktop (for development) and roboRIO
            targetPlatform wpi.platforms.desktop
            targetPlatform wpi.platforms.roborio
            javaCompileTasks << compileJava // set javaCompileTasks to any java compile tasks that contain your JNI classes. It is a list of tasks
            jniCrossCompileOptions << JniCrossCompileOptions(wpi.platforms.roborio)
            // Include C++ sources
            sources.cpp {
                source {
                    srcDir 'src/main/cpp'
                    include '**/*.cpp', '**/*.cc'
                }
                exportedHeaders {
                    srcDir 'src/main/cpp/include'
                }
            }
            binaries.all {
                // Don't build static libraries
                if (it instanceof StaticLibraryBinarySpec) {
                    it.buildable = false
                }
                if (it.targetPlatform.name.contains(wpi.platforms.roborio)) {
                    useLibrary(it, "wpilibjni")
                } else {
                    useLibrary(it, "wpilibjni_common")
                }
            }
        }
    }
}
if(Os.isFamily(Os.FAMILY_WINDOWS)) {
    model {
        binaries {
            all {
                if (targetPlatform.name == wpi.platforms.roborio) {
                    cppCompiler.args << '-Wall' << '-Wextra' << '-ffast-math' << '-fno-finite-math-only'
                }
                else if (targetPlatform.name == wpi.platforms.desktop) {
                    cppCompiler.args << '/W3'
                }
            }
        }
    }
}
else {
    model {
        binaries {
            all {
                if (targetPlatform.name == wpi.platforms.roborio) {
                    cppCompiler.args << '-Wall' << '-Wextra' << '-ffast-math' << '-fno-finite-math-only'
                }
                else if (targetPlatform.name == wpi.platforms.desktop) {
                    cppCompiler.args << '-Wall' << '-Wextra' << '-ffast-math' << '-fno-finite-math-only'
                }
            }
        }
    }
}

task updateJNIHeaders(type: Copy, group: 'Development', description: 'Copies JNI generated headers into the JNI headers directory.') {
    dependsOn assemble

    from 'build/jniinclude/compileJava'
    into 'src/main/cpp/include/jni'
}

task copyLibLinuxx8664Debug(type: Copy, group: 'Development', description: 'Copies the dynamic library for linux x86-64 debug to the root of the project.') {
    dependsOn assemble

    from 'build/libs/jniLibrary/shared/linuxx86-64/debug'
    into '.'
    rename { String fileName ->
        fileName.replace('JniLibrary', 'RobotPathfinder')
    }
}
task copyLibLinuxx8664Release(type: Copy, group: 'Development', description: 'Copies the dynamic library for linux x86-64 release to the root of the project.') {
    dependsOn assemble

    from 'build/libs/jniLibrary/shared/linuxx86-64/release'
    into '.'
    rename { String fileName ->
        fileName.replace('JniLibrary', 'RobotPathfinder')
    }
}
task copyLibWindowsx8664Debug(type: Exec, group: 'Development', description: 'Copies the dynamic library for windows x86-64 debug to the root of the project.') {
    dependsOn assemble
    
    commandLine 'cmd', '/c', '\"copy build\\libs\\jniLibrary\\shared\\windowsx86-64\\debug\\JniLibrary.dll RobotPathfinder.dll\"'
}
task copyLibWindowsx8664Release(type: Exec, group: 'Development', description: 'Copies the dynamic library for windows x86-64 release to the root of the project.') {
    dependsOn assemble

    commandLine 'cmd', '/c', '\"copy build\\libs\\jniLibrary\\shared\\windowsx86-64\\release\\JniLibrary.dll RobotPathfinder.dll\"'
}

task copyLibDebug(group: 'Development', description: 'Copies the correct debug dynamic library to the root of the project.') {
    if(System.getProperty('os.arch') != 'amd64' && System.getProperty('os.arch') != 'x86_64') {
        throw new GradleException('OS architecture not supported')
    }
    
    println('Detected architeture: ' + System.getProperty('os.arch'))
    if(Os.isFamily(Os.FAMILY_UNIX)) {
        println('Detected OS: UNIX')
        dependsOn copyLibLinuxx8664Debug
    }
    else if(Os.isFamily(Os.FAMILY_WINDOWS)) {
        println('Detected OS: Windows')
        dependsOn copyLibWindowsx8664Debug
    }
    else {
        throw new GradleException('OS not supported')
    }
}

task copyLibRelease(group: 'Development', description: 'Copies the correct release dynamic library to the root of the project.') {
    if(System.getProperty('os.arch') != 'amd64' && System.getProperty('os.arch') != 'x86_64') {
        throw new GradleException('OS architecture not supported')
    }

    println('Detected architeture: ' + System.getProperty('os.arch'))
    if(Os.isFamily(Os.FAMILY_UNIX)) {
        println('Detected OS: UNIX')
        dependsOn copyLibLinuxx8664Release
    }
    else if(Os.isFamily(Os.FAMILY_WINDOWS)) {
        println('Detected OS: Windows')
        dependsOn copyLibWindowsx8664Release
    }
    else {
        throw new GradleException('OS not supported')
    }
}

test {
    dependsOn copyLibRelease
}

// Add sources to the jar
jar {
    from sourceSets.main.allSource
    
    archiveName 'RobotPathfinder-' + project.version + '.jar'
}

def visualizerMainClass = 'com.arctos6135.robotpathfinder.tools.TrajectoryVisualizationTool'
// This task assembles the trajecotry visualizer jar
// This jar is a fat jar
task visualizerJar(type: Jar, group: 'Build', description: 'Assembles a runnable jar that runs the visualizer.') {
    dependsOn build

    // Include outputs
    from(sourceSets.main.output) {
        include '**'
        exclude '**/follower/*', '**/package-info.java'
    }
    // Add manifest attribute to make it runnable
    manifest {
        attributes 'Main-Class': visualizerMainClass
    }
    // Set archive name
    archiveName 'Trajectory-Visualizer-' + project.version + '.jar'

    // Include all dependencies in this jar
    classifier = 'all'
    from { 
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

task fatJar(type: Jar, group: 'Build', description: 'Assembles a jar of the library, including the libraries for the Grapher class.') {
    dependsOn build

    archiveName 'RobotPathfinder-' + project.version + '-all.jar'

    // Collect all
    classifier = 'all'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }

    with jar
}

task markVisualizerJarExecutable(type: Exec, group: 'Archive', description: 'Sets the Trajectory Visualizer jar to be executable.') {
    commandLine 'chmod', '+x', 'output/Trajectory-Visualizer-' + project.version + '.jar'
}

task copyJars(type: Copy, group: 'Archive', description: 'Copies all generated jars to the output directory.') {
    dependsOn jar
    dependsOn fatJar
    dependsOn visualizerJar
    from 'build/libs'
    into 'output'

    // If the OS is part of the UNIX family, also chmod the visualizer jar to be executable
    if(Os.isFamily(Os.FAMILY_UNIX)) {
        finalizedBy markVisualizerJarExecutable
    }
}

task zipDoc(type: Zip, group: 'Archive', description: 'Zips the generated JavaDoc and puts it in the output directory.') {
    dependsOn javadoc
    from 'build/docs/javadoc'
    destinationDir file('output')
    archiveName 'RobotPathfinder-Doc-' + project.version + '.zip'
}

task allArchives(group: 'Archive', description: 'Builds the project, generates the JavaDoc and jars, zips JavaDoc and copies all items to the output directory.') {
    dependsOn jar
    dependsOn visualizerJar
    dependsOn fatJar
    dependsOn copyJars
    dependsOn zipDoc
}

task cleanAll(type: Exec, group: 'Clean', description: 'Removes all compiled artifacts.') {
    if(Os.isFamily(Os.FAMILY_UNIX)) {
        commandLine 'rm', '-rf', 'bin', 'build', 'output', 'libRobotPathfinder.so'
    }
    else {
        commandLine 'cmd', '/c', '\"del /s /q /f bin build output RobotPathfinder.dll \
                & rd /s /q bin & rd /s /q build & rd /s /q output\"'
    }
}
